generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          String                   @id @default(uuid())
  email                       String                   @unique
  password                    String
  role                        Role
  firstName                   String
  lastName                    String
  phone                       String?
  isActive                    Boolean                  @default(true)
  isSuperAdmin                Boolean                  @default(false)
  passwordChanged             Boolean                  @default(false)
  lastLogin                   DateTime?
  failedLoginAttempts         Int                      @default(0)
  lockedUntil                 DateTime?
  createdAt                   DateTime                 @default(now())
  updatedAt                   DateTime                 @updatedAt
  profilePicture              String?
  registrationToken           String?                  @unique
  department                  String?
  createdAttendanceLinks      AttendanceLink[]
  auditLogs                   AuditLog[]
  handledBatches              BatchTransfer[]          @relation("Handler")
  receivedBatches             BatchTransfer[]          @relation("Receiver")
  classAttendanceRecords      ClassAttendanceRecord[]
  createdExams                ExamSession[]            @relation("CreatedBy")
  invigilatedExams            ExamSession[]            @relation("Invigilator")
  invigilatorHistory          ExamSessionInvigilator[]
  assignedIncidents           Incident[]               @relation("IncidentAssignee")
  reportedIncidents           Incident[]               @relation("IncidentReporter")
  incidentAttachments         IncidentAttachment[]
  incidentComments            IncidentComment[]
  incidentStatusChanges       IncidentStatusHistory[]
  passwordResetTokens         PasswordResetToken[]
  refreshTokens               RefreshToken[]
  createdRegistrationSessions RegistrationSession[]
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RegistrationSession {
  id          String    @id @default(uuid())
  qrToken     String    @unique
  createdById String
  expiresAt   DateTime
  used        Boolean   @default(false)
  usedAt      DateTime?
  createdAt   DateTime  @default(now())
  department  String?
  createdBy   User      @relation(fields: [createdById], references: [id])

  @@index([qrToken])
  @@index([expiresAt])
  @@index([used])
}

model BlacklistedToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([expiresAt])
}

model Student {
  id                    String            @id @default(uuid())
  indexNumber           String            @unique
  firstName             String
  lastName              String
  program               String
  level                 Int
  qrCode                String            @unique
  createdAt             DateTime          @default(now())
  profilePicture        String
  biometricDeviceId     String?
  biometricEnrolledAt   DateTime?
  biometricProvider     String?
  biometricTemplateHash String?           @unique
  updatedAt             DateTime          @updatedAt
  department            String?
  option                String?
  biometricCounter      Int?              @default(0)
  biometricCredentialId String?           @unique
  biometricPublicKey    String?
  biometricTransports   String[]          @default([])
  enrollmentLinks       AttendanceLink[]  @relation("enrollmentLinks")
  classAttendances      ClassAttendance[]
  attendances           ExamAttendance[]
  incidents             Incident[]

  @@index([biometricTemplateHash])
}

model ExamSession {
  id               String                   @id @default(uuid())
  batchQrCode      String                   @unique
  courseCode       String
  courseName       String
  lecturerId       String
  lecturerName     String
  department       String
  faculty          String
  venue            String
  examDate         DateTime
  status           BatchStatus              @default(NOT_STARTED)
  createdById      String
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  invigilatorId    String?
  invigilatorName  String?
  transfers        BatchTransfer[]
  attendances      ExamAttendance[]
  createdBy        User                     @relation("CreatedBy", fields: [createdById], references: [id])
  invigilator      User?                    @relation("Invigilator", fields: [invigilatorId], references: [id])
  invigilators     ExamSessionInvigilator[]
  expectedStudents ExamSessionStudent[]
  incidents        Incident[]
}

model ExamSessionStudent {
  id            String      @id @default(uuid())
  examSessionId String
  createdAt     DateTime    @default(now())
  firstName     String?
  indexNumber   String
  lastName      String?
  level         Int?
  program       String?
  examSession   ExamSession @relation(fields: [examSessionId], references: [id], onDelete: Cascade)

  @@unique([examSessionId, indexNumber])
  @@index([examSessionId])
  @@index([indexNumber])
}

model ExamSessionInvigilator {
  id              String          @id @default(uuid())
  examSessionId   String
  userId          String
  role            InvigilatorRole @default(ASSISTANT)
  assignedAt      DateTime        @default(now())
  firstScanAt     DateTime?
  lastScanAt      DateTime?
  studentsScanned Int             @default(0)
  examSession     ExamSession     @relation(fields: [examSessionId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id])

  @@unique([examSessionId, userId])
  @@index([examSessionId])
  @@index([userId])
}

model ExamAttendance {
  id              String           @id @default(uuid())
  studentId       String
  examSessionId   String
  entryTime       DateTime
  exitTime        DateTime?
  submissionTime  DateTime?
  status          AttendanceStatus @default(PRESENT)
  discrepancyNote String?
  examSession     ExamSession      @relation(fields: [examSessionId], references: [id])
  student         Student          @relation(fields: [studentId], references: [id])
  incidents       Incident[]

  @@unique([studentId, examSessionId])
}

model BatchTransfer {
  id              String         @id @default(uuid())
  examSessionId   String
  fromHandlerId   String
  toHandlerId     String
  requestedAt     DateTime       @default(now())
  confirmedAt     DateTime?
  status          TransferStatus @default(PENDING)
  examsExpected   Int            @map("scriptsExpected")
  examsReceived   Int?           @map("scriptsReceived")
  discrepancyNote String?
  location        String?
  examSession     ExamSession    @relation(fields: [examSessionId], references: [id])
  fromHandler     User           @relation("Handler", fields: [fromHandlerId], references: [id])
  toHandler       User           @relation("Receiver", fields: [toHandlerId], references: [id])
  incidents       Incident[]

  @@index([examSessionId])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String
  entity    String
  entityId  String
  details   Json?
  ipAddress String?
  timestamp DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@index([entityId])
  @@index([timestamp])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Incident {
  id              String                  @id @default(uuid())
  incidentNumber  String                  @unique
  type            IncidentType
  severity        IncidentSeverity
  status          IncidentStatus          @default(REPORTED)
  isConfidential  Boolean                 @default(false)
  autoCreated     Boolean                 @default(false)
  title           String
  description     String
  location        String?
  reporterId      String
  assigneeId      String?
  studentId       String?
  examSessionId   String?
  attendanceId    String?
  transferId      String?
  incidentDate    DateTime
  reportedAt      DateTime                @default(now())
  assignedAt      DateTime?
  resolvedAt      DateTime?
  closedAt        DateTime?
  metadata        Json?
  resolutionNotes String?
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  assignee        User?                   @relation("IncidentAssignee", fields: [assigneeId], references: [id])
  attendance      ExamAttendance?         @relation(fields: [attendanceId], references: [id])
  examSession     ExamSession?            @relation(fields: [examSessionId], references: [id])
  reporter        User                    @relation("IncidentReporter", fields: [reporterId], references: [id])
  student         Student?                @relation(fields: [studentId], references: [id])
  transfer        BatchTransfer?          @relation(fields: [transferId], references: [id])
  attachments     IncidentAttachment[]
  comments        IncidentComment[]
  statusHistory   IncidentStatusHistory[]

  @@index([reporterId])
  @@index([assigneeId])
  @@index([studentId])
  @@index([examSessionId])
  @@index([status])
  @@index([severity])
  @@index([type])
  @@index([incidentDate])
  @@index([isConfidential])
}

model IncidentAttachment {
  id         String   @id @default(uuid())
  incidentId String
  fileName   String
  filePath   String
  fileType   String
  fileSize   Int
  uploadedBy String
  uploadedAt DateTime @default(now())
  metadata   Json?
  incident   Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  uploader   User     @relation(fields: [uploadedBy], references: [id])

  @@index([incidentId])
}

model IncidentComment {
  id         String   @id @default(uuid())
  incidentId String
  userId     String
  comment    String
  isInternal Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  incident   Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id])

  @@index([incidentId])
  @@index([userId])
}

model IncidentStatusHistory {
  id         String          @id @default(uuid())
  incidentId String
  fromStatus IncidentStatus?
  toStatus   IncidentStatus
  changedBy  String
  reason     String?
  changedAt  DateTime        @default(now())
  user       User            @relation(fields: [changedBy], references: [id])
  incident   Incident        @relation(fields: [incidentId], references: [id], onDelete: Cascade)

  @@index([incidentId])
  @@index([changedAt])
}

model AttendanceLink {
  id                String    @id @default(uuid())
  recordId          String?
  linkToken         String    @unique
  createdBy         String
  geolocation       Json?
  networkIdentifier String?
  expiresAt         DateTime
  maxUses           Int?
  usesCount         Int       @default(0)
  isActive          Boolean   @default(true)
  deactivatedAt     DateTime?
  createdAt         DateTime  @default(now())
  enrollmentToken   String?   @unique
  linkType          String    @default("ATTENDANCE")
  studentId         String?
  createdByUser     User      @relation(fields: [createdBy], references: [id])
  student           Student?  @relation("enrollmentLinks", fields: [studentId], references: [id])

  @@index([linkToken])
  @@index([recordId, isActive])
  @@index([enrollmentToken])
  @@index([studentId, linkType])
}

model AttendanceSession {
  id                String                  @id @default(uuid())
  deviceId          String                  @unique
  deviceName        String?
  sessionToken      String                  @unique
  isActive          Boolean                 @default(true)
  lastActivity      DateTime                @updatedAt
  createdAt         DateTime                @default(now())
  attendanceRecords ClassAttendanceRecord[]

  @@index([deviceId])
  @@index([isActive])
}

model ClassAttendanceRecord {
  id            String            @id @default(uuid())
  sessionId     String
  lecturerName  String?
  courseName    String?
  courseCode    String?
  startTime     DateTime          @default(now())
  endTime       DateTime?
  status        RecordingStatus   @default(IN_PROGRESS)
  totalStudents Int               @default(0)
  notes         String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  userId        String?
  venue         String?
  students      ClassAttendance[]
  session       AttendanceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user          User?             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([userId])
  @@index([startTime])
}

model ClassAttendance {
  id                  String                @id @default(uuid())
  recordId            String
  studentId           String
  scanTime            DateTime              @default(now())
  status              ClassAttendanceStatus @default(PRESENT)
  confirmedAt         DateTime?
  lecturerConfirmed   Boolean               @default(true)
  biometricConfidence Float?
  deviceId            String?
  linkTokenUsed       String?
  verificationMethod  AttendanceMethod?     @default(QR_CODE)
  record              ClassAttendanceRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)
  student             Student               @relation(fields: [studentId], references: [id])

  @@unique([recordId, studentId])
  @@index([recordId])
  @@index([scanTime])
}

enum Role {
  ADMIN
  INVIGILATOR
  DEPARTMENT_HEAD
  FACULTY_OFFICER
  LECTURER
  CLASS_REP
}

enum BatchStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  IN_TRANSIT
  WITH_LECTURER
  UNDER_GRADING
  GRADED
  RETURNED
  COMPLETED
}

enum InvigilatorRole {
  PRIMARY
  ASSISTANT
}

enum AttendanceStatus {
  PRESENT
  SUBMITTED
  LEFT_WITHOUT_SUBMITTING
  ABSENT
}

enum TransferStatus {
  PENDING
  CONFIRMED
  DISCREPANCY_REPORTED
  RESOLVED
}

enum IncidentType {
  MALPRACTICE
  HEALTH_ISSUE
  EXAM_DAMAGE
  EQUIPMENT_FAILURE
  DISRUPTION
  SECURITY_BREACH
  PROCEDURAL_VIOLATION
  OTHER
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentStatus {
  REPORTED
  UNDER_INVESTIGATION
  RESOLVED
  CLOSED
  ESCALATED
}

enum RecordingStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ClassAttendanceStatus {
  PRESENT
  LATE
  EXCUSED
}

enum AttendanceMethod {
  QR_CODE
  MANUAL_INDEX
  BIOMETRIC_FINGERPRINT
  BIOMETRIC_FACE
}
