// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users & Roles
model User {
  id                String   @id @default(uuid())
  email             String   @unique
  password          String
  role              Role
  firstName         String
  lastName          String
  phone             String?
  profilePicture    String?  // URL or path to profile picture
  isActive          Boolean  @default(true)
  isSuperAdmin      Boolean  @default(false)
  passwordChanged   Boolean  @default(false)
  lastLogin         DateTime?
  failedLoginAttempts Int    @default(0)
  lockedUntil       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  handledBatches  BatchTransfer[] @relation("Handler")
  receivedBatches BatchTransfer[] @relation("Receiver")
  createdExams    ExamSession[]
  auditLogs       AuditLog[]
  refreshTokens   RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  
  // Incident Management relations
  reportedIncidents      Incident[]              @relation("IncidentReporter")
  assignedIncidents      Incident[]              @relation("IncidentAssignee")
  incidentComments       IncidentComment[]
  incidentStatusChanges  IncidentStatusHistory[]
  incidentAttachments    IncidentAttachment[]
}

// Password Reset Tokens
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Blacklisted Access Tokens (for immediate session revocation)
model BlacklistedToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime // When the token would naturally expire
  createdAt DateTime @default(now())
  
  @@index([token])
  @@index([expiresAt])
}

enum Role {
  ADMIN
  INVIGILATOR
  DEPARTMENT_HEAD
  FACULTY_OFFICER
  LECTURER
  CLASS_REP
}

// Students
model Student {
  id          String   @id @default(uuid())
  indexNumber String   @unique
  firstName   String
  lastName    String
  program     String
  level       Int
  qrCode      String   @unique
  createdAt   DateTime @default(now())
  
  attendances       ExamAttendance[]
  classAttendances  ClassAttendance[]
  incidents         Incident[]
}

// Exam Sessions
model ExamSession {
  id           String      @id @default(uuid())
  batchQrCode  String      @unique
  courseCode   String
  courseName   String
  lecturerId   String
  lecturerName String
  department   String
  faculty      String
  venue        String
  examDate     DateTime
  status       BatchStatus @default(NOT_STARTED)
  createdById  String
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  createdBy        User                 @relation(fields: [createdById], references: [id])
  attendances      ExamAttendance[]
  transfers        BatchTransfer[]
  expectedStudents ExamSessionStudent[]
  incidents        Incident[]
}

enum BatchStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  IN_TRANSIT
  WITH_LECTURER
  UNDER_GRADING
  GRADED
  RETURNED
  COMPLETED
}

// Expected Students for Exam Sessions (Raw Data - No User Account Required)
model ExamSessionStudent {
  id            String      @id @default(uuid())
  examSessionId String
  indexNumber   String      // Student's index number (raw data)
  firstName     String?     // Optional: student name from CSV
  lastName      String?     // Optional: student name from CSV
  program       String?     // Optional: program from CSV
  level         Int?        // Optional: level from CSV
  createdAt     DateTime    @default(now())
  
  examSession ExamSession @relation(fields: [examSessionId], references: [id], onDelete: Cascade)
  
  @@unique([examSessionId, indexNumber])
  @@index([examSessionId])
  @@index([indexNumber])
}

// Student Attendance & Submission
model ExamAttendance {
  id              String           @id @default(uuid())
  studentId       String
  examSessionId   String
  entryTime       DateTime
  exitTime        DateTime?
  submissionTime  DateTime?
  status          AttendanceStatus @default(PRESENT)
  discrepancyNote String?
  
  student     Student     @relation(fields: [studentId], references: [id])
  examSession ExamSession @relation(fields: [examSessionId], references: [id])
  incidents   Incident[]
  
  @@unique([studentId, examSessionId])
}

enum AttendanceStatus {
  PRESENT
  SUBMITTED
  LEFT_WITHOUT_SUBMITTING
  ABSENT
}

// Script Transfer Chain
model BatchTransfer {
  id              String         @id @default(uuid())
  examSessionId   String
  fromHandlerId   String
  toHandlerId     String
  requestedAt     DateTime       @default(now())
  confirmedAt     DateTime?
  status          TransferStatus @default(PENDING)
  scriptsExpected Int
  scriptsReceived Int?
  discrepancyNote String?
  location        String?
  
  examSession ExamSession @relation(fields: [examSessionId], references: [id])
  fromHandler User        @relation("Handler", fields: [fromHandlerId], references: [id])
  toHandler   User        @relation("Receiver", fields: [toHandlerId], references: [id])
  incidents   Incident[]
  
  @@index([examSessionId])
}

enum TransferStatus {
  PENDING
  CONFIRMED
  DISCREPANCY_REPORTED
  RESOLVED
}

// Audit Trail
model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  action    String
  entity    String
  entityId  String
  details   Json?
  ipAddress String?
  timestamp DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id])
  
  @@index([entityId])
  @@index([timestamp])
  @@index([userId])
}

// Class Attendance System Models

// Class Attendance Session (Device-based sessions)
model AttendanceSession {
  id              String   @id @default(uuid())
  deviceId        String   @unique // Device UUID or fingerprint
  deviceName      String?  // User-provided device label
  sessionToken    String   @unique // Unique session token
  isActive        Boolean  @default(true)
  lastActivity    DateTime @updatedAt
  createdAt       DateTime @default(now())

  attendanceRecords ClassAttendanceRecord[]

  @@index([deviceId])
  @@index([isActive])
}

// Class Attendance Recording
model ClassAttendanceRecord {
  id               String            @id @default(uuid())
  sessionId        String
  lecturerName     String?           // Optional label
  courseName       String?           // Optional label
  courseCode       String?           // Optional label
  startTime        DateTime          @default(now())
  endTime          DateTime?
  status           RecordingStatus   @default(IN_PROGRESS)
  totalStudents    Int               @default(0)
  notes            String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  session          AttendanceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  students         ClassAttendance[]

  @@index([sessionId])
  @@index([startTime])
}

// Individual Student Attendance
model ClassAttendance {
  id               String                  @id @default(uuid())
  recordId         String
  studentId        String                  // From Student model
  scanTime         DateTime                @default(now())
  status           ClassAttendanceStatus   @default(PRESENT)

  record           ClassAttendanceRecord   @relation(fields: [recordId], references: [id], onDelete: Cascade)
  student          Student                 @relation(fields: [studentId], references: [id])

  @@unique([recordId, studentId])
  @@index([recordId])
  @@index([scanTime])
}

// Enums for Class Attendance System
enum RecordingStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ClassAttendanceStatus {
  PRESENT
  LATE
  EXCUSED
}

// Refresh Tokens
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

// ============================================
// INCIDENT MANAGEMENT SYSTEM
// ============================================

// Incident Types
enum IncidentType {
  MALPRACTICE           // Cheating, unauthorized materials
  HEALTH_ISSUE          // Medical emergency, student unwell
  SCRIPT_DAMAGE         // Water damage, torn papers
  EQUIPMENT_FAILURE     // Scanner issues, printer problems
  DISRUPTION            // Fire alarm, power outage
  SECURITY_BREACH       // Unauthorized access
  PROCEDURAL_VIOLATION  // Protocol not followed
  OTHER                 // Miscellaneous
}

enum IncidentSeverity {
  LOW       // Minor issue, no immediate action needed
  MEDIUM    // Requires attention within 24h
  HIGH      // Urgent, requires immediate attention
  CRITICAL  // Emergency, escalate immediately
}

enum IncidentStatus {
  REPORTED              // Initial state, awaiting review
  UNDER_INVESTIGATION   // Assigned and being investigated
  RESOLVED              // Investigation complete, action taken
  CLOSED                // No further action needed
  ESCALATED             // Sent to higher authority
}

// Main Incident Model
model Incident {
  id                String            @id @default(uuid())
  incidentNumber    String            @unique // Auto-generated: INC-YYYYMMDD-XXXX
  
  // Classification
  type              IncidentType
  severity          IncidentSeverity
  status            IncidentStatus    @default(REPORTED)
  isConfidential    Boolean           @default(false)
  autoCreated       Boolean           @default(false)
  
  // Description
  title             String            // Brief summary
  description       String            @db.Text // Detailed description
  location          String?           // Venue/room where incident occurred
  
  // Relationships
  reporterId        String            // User who reported
  assigneeId        String?           // User assigned to investigate
  studentId         String?           // Involved student (optional)
  examSessionId     String?           // Related exam session (optional)
  attendanceId      String?           // Related attendance record (optional)
  transferId        String?           // Related batch transfer (optional)
  
  // Metadata
  incidentDate      DateTime          // When incident occurred
  reportedAt        DateTime          @default(now())
  assignedAt        DateTime?
  resolvedAt        DateTime?
  closedAt          DateTime?
  
  // Additional data
  metadata          Json?             // Flexible field for extra context
  resolutionNotes   String?           @db.Text
  
  // Relations
  reporter          User              @relation("IncidentReporter", fields: [reporterId], references: [id], onDelete: Restrict)
  assignee          User?             @relation("IncidentAssignee", fields: [assigneeId], references: [id], onDelete: SetNull)
  student           Student?          @relation(fields: [studentId], references: [id], onDelete: SetNull)
  examSession       ExamSession?      @relation(fields: [examSessionId], references: [id], onDelete: SetNull)
  attendance        ExamAttendance?   @relation(fields: [attendanceId], references: [id], onDelete: SetNull)
  transfer          BatchTransfer?    @relation(fields: [transferId], references: [id], onDelete: SetNull)
  
  attachments       IncidentAttachment[]
  comments          IncidentComment[]
  statusHistory     IncidentStatusHistory[]
  
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([reporterId])
  @@index([assigneeId])
  @@index([studentId])
  @@index([examSessionId])
  @@index([status])
  @@index([severity])
  @@index([type])
  @@index([incidentDate])
  @@index([isConfidential])
}

// Incident Attachments (Photos, Videos, Documents)
model IncidentAttachment {
  id           String   @id @default(uuid())
  incidentId   String
  
  fileName     String   // Original filename
  filePath     String   // Relative path: uploads/incidents/{incidentId}/{filename}
  fileType     String   // MIME type: image/jpeg, video/mp4, application/pdf
  fileSize     Int      // Size in bytes
  
  uploadedBy   String   // User who uploaded
  uploadedAt   DateTime @default(now())
  
  incident     Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  uploader     User     @relation(fields: [uploadedBy], references: [id], onDelete: Restrict)
  
  @@index([incidentId])
}

// Comments/Notes Thread
model IncidentComment {
  id          String   @id @default(uuid())
  incidentId  String
  userId      String
  
  comment     String   @db.Text
  isInternal  Boolean  @default(false) // Internal notes vs public comments
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  incident    Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  
  @@index([incidentId])
  @@index([userId])
}

// Status Change History (Audit Trail)
model IncidentStatusHistory {
  id          String         @id @default(uuid())
  incidentId  String
  
  fromStatus  IncidentStatus?
  toStatus    IncidentStatus
  changedBy   String
  reason      String?        @db.Text
  
  changedAt   DateTime       @default(now())
  
  incident    Incident       @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user        User           @relation(fields: [changedBy], references: [id], onDelete: Restrict)
  
  @@index([incidentId])
  @@index([changedAt])
}
