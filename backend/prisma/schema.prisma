// ============================================================================
// COMPLETE PRISMA SCHEMA FOR ATTENDANCE SYSTEM
// ============================================================================
// This is the FULL schema. Replace your existing schema.prisma with this.
// All models related to attendance are included here.
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER MODEL (Complete)
// ============================================================================
model User {
  id                          String                     @id @default(uuid())
  email                       String                     @unique
  password                    String
  role                        Role
  firstName                   String
  lastName                    String
  phone                       String?
  isActive                    Boolean                    @default(true)
  isSuperAdmin                Boolean                    @default(false)
  passwordChanged             Boolean                    @default(false)
  lastLogin                   DateTime?
  failedLoginAttempts         Int                        @default(0)
  lockedUntil                 DateTime?
  createdAt                   DateTime                   @default(now())
  updatedAt                   DateTime                   @updatedAt
  profilePicture              String?
  registrationToken           String?                    @unique
  department                  String?
  
  // Attendance Relations (NEW - replaces old relations)
  createdSessions             AttendanceSession[]        @relation("SessionCreator")
  assistedSessions            AttendanceSessionAssistant[]
  createdLinks                AttendanceLink[]
  recordedAttendance          StudentAttendance[]        @relation("RecordedBy")
  confirmedAttendance         StudentAttendance[]        @relation("ConfirmedBy")
  createdTemplates            SessionTemplate[]          @relation("CreatedTemplates")
  
  // Existing Relations (Keep these if you're using exam/incident features)
  createdRegistrationSessions RegistrationSession[]
  passwordResetTokens         PasswordResetToken[]
  refreshTokens               RefreshToken[]
  auditLogs                   AuditLog[]
  createdExams                ExamSession[]              @relation("CreatedBy")
  invigilatedExams            ExamSession[]              @relation("Invigilator")
  invigilatorHistory          ExamSessionInvigilator[]
  assignedIncidents           Incident[]                 @relation("IncidentAssignee")
  reportedIncidents           Incident[]                 @relation("IncidentReporter")
  incidentAttachments         IncidentAttachment[]
  incidentComments            IncidentComment[]
  incidentStatusChanges       IncidentStatusHistory[]
  handledBatches              BatchTransfer[]            @relation("Handler")
  receivedBatches             BatchTransfer[]            @relation("Receiver")

  @@index([email])
  @@index([isActive])
  @@index([role])
}

// ============================================================================
// STUDENT MODEL (Complete with biometric fields)
// ============================================================================
model Student {
  id                    String              @id @default(uuid())
  indexNumber           String              @unique
  firstName             String
  lastName              String
  program               String
  level                 Int
  department            String?
  option                String?
  qrCode                String              @unique
  profilePicture        String?
  
  // Biometric fields
  biometricEnrolled     Boolean             @default(false)
  biometricProvider     String?             // "FINGERPRINT" or "FACE"
  biometricTemplateHash String?             @unique
  biometricEnrolledAt   DateTime?
  biometricDeviceId     String?
  biometricCounter      Int?                @default(0)
  biometricCredentialId String?             @unique
  biometricPublicKey    String?
  biometricTransports   String[]            @default([])
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Attendance Relations (NEW)
  attendance            StudentAttendance[]
  enrollmentLinks       AttendanceLink[]    @relation("BiometricEnrollment")
  
  // Existing Relations (Keep these if you're using exam/incident features)
  attendances           ExamAttendance[]
  incidents             Incident[]

  @@index([indexNumber])
  @@index([biometricTemplateHash])
  @@index([department])
  @@index([program])
  @@index([qrCode])
}

// ============================================================================
// ATTENDANCE SESSION MODEL (Main session container)
// ============================================================================
model AttendanceSession {
  id                    String                     @id @default(uuid())
  
  // Session Info
  courseCode            String
  courseName            String
  venue                 String?
  lecturerName          String?
  notes                 String?
  
  // Creator
  createdBy             String
  creator               User                       @relation("SessionCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  
  // Timing
  startTime             DateTime                   @default(now())
  endTime               DateTime?
  status                SessionStatus              @default(IN_PROGRESS)
  
  // Student tracking
  expectedStudentCount  Int                        @default(0)
  
  // Metadata for analytics (store custom data as JSON)
  metadata              Json?
  
  createdAt             DateTime                   @default(now())
  updatedAt             DateTime                   @updatedAt
  
  // Relations
  attendance            StudentAttendance[]
  links                 AttendanceLink[]
  assistants            AttendanceSessionAssistant[]
  
  @@index([createdBy, status])
  @@index([courseCode])
  @@index([startTime])
  @@index([status])
  @@index([createdBy])
}

// ============================================================================
// SESSION ASSISTANTS (for collaborative marking - NEW)
// ============================================================================
model AttendanceSessionAssistant {
  id                String            @id @default(uuid())
  sessionId         String
  userId            String
  role              AssistantRole     @default(ASSISTANT)
  addedAt           DateTime          @default(now())
  recordedCount     Int               @default(0)
  
  session           AttendanceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
}

// ============================================================================
// STUDENT ATTENDANCE RECORDS (Individual attendance marks)
// ============================================================================
model StudentAttendance {
  id                    String              @id @default(uuid())
  sessionId             String
  studentId             String
  
  // Verification details
  verificationMethod    VerificationMethod
  status                AttendanceStatus    @default(PRESENT)
  
  // Timing
  markedAt              DateTime            @default(now())
  
  // Confirmation (for self-marked attendance)
  requiresConfirmation  Boolean             @default(false)
  confirmedBy           String?
  confirmedAt           DateTime?
  confirmer             User?               @relation("ConfirmedBy", fields: [confirmedBy], references: [id], onDelete: SetNull)
  
  // Recording details
  recordedBy            String?
  recorder              User?               @relation("RecordedBy", fields: [recordedBy], references: [id], onDelete: SetNull)
  
  // Optional metadata
  deviceId              String?
  biometricConfidence   Float?
  linkTokenUsed         String?
  location              Json?               // { lat, lng }
  
  // Audit
  metadata              Json?
  
  session               AttendanceSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  student               Student             @relation(fields: [studentId], references: [id], onDelete: Cascade)
  
  @@unique([sessionId, studentId])
  @@index([sessionId])
  @@index([studentId])
  @@index([markedAt])
  @@index([requiresConfirmation])
  @@index([status])
}

// ============================================================================
// ATTENDANCE LINKS (Self-service and biometric enrollment)
// ============================================================================
model AttendanceLink {
  id                String            @id @default(uuid())
  
  // Link details
  linkToken         String            @unique
  linkType          LinkType          @default(ATTENDANCE)
  
  // Association
  sessionId         String?
  studentId         String?           // For biometric enrollment links
  
  // Creator
  createdBy         String
  creator           User              @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  
  // Settings
  expiresAt         DateTime
  maxUses           Int?
  usesCount         Int               @default(0)
  
  // Geofencing
  requiresLocation  Boolean           @default(false)
  geofence          Json?             // { lat, lng, radiusMeters }
  
  // Status
  isActive          Boolean           @default(true)
  deactivatedAt     DateTime?
  
  createdAt         DateTime          @default(now())
  
  // Relations
  session           AttendanceSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  enrollmentStudent Student?          @relation("BiometricEnrollment", fields: [studentId], references: [id], onDelete: Cascade)
  
  @@index([linkToken])
  @@index([sessionId, isActive])
  @@index([expiresAt])
  @@index([linkType])
  @@index([createdBy])
}

// ============================================================================
// SESSION TEMPLATES (for quick session creation)
// ============================================================================
model SessionTemplate {
  id                    String    @id @default(uuid())
  name                  String
  
  // Template data
  courseCode            String
  courseName            String
  venue                 String?
  expectedStudentCount  Int       @default(0)
  
  // Creator
  createdBy             String
  creator               User      @relation("CreatedTemplates", fields: [createdBy], references: [id], onDelete: Cascade)
  
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  @@index([createdBy])
  @@index([courseCode])
}

// ============================================================================
// ENUMS FOR ATTENDANCE SYSTEM
// ============================================================================

enum SessionStatus {
  IN_PROGRESS
  PAUSED
  COMPLETED
  CANCELLED
}

enum AttendanceStatus {
  PRESENT
  LATE
  EXCUSED
  ABSENT
}

enum VerificationMethod {
  QR_SCAN
  MANUAL_ENTRY
  BIOMETRIC_FINGERPRINT
  BIOMETRIC_FACE
  LINK_SELF_MARK
}

enum LinkType {
  ATTENDANCE
  BIOMETRIC_ENROLLMENT
}

enum AssistantRole {
  ASSISTANT      // Can mark attendance
  OBSERVER       // Can view only
}

// ============================================================================
// EXISTING MODELS (Keep these unchanged if you're using them)
// ============================================================================

enum Role {
  ADMIN
  INVIGILATOR
  DEPARTMENT_HEAD
  FACULTY_OFFICER
  LECTURER
  CLASS_REP
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RegistrationSession {
  id          String    @id @default(uuid())
  qrToken     String    @unique
  createdById String
  expiresAt   DateTime
  used        Boolean   @default(false)
  usedAt      DateTime?
  createdAt   DateTime  @default(now())
  department  String?
  createdBy   User      @relation(fields: [createdById], references: [id])

  @@index([qrToken])
  @@index([expiresAt])
  @@index([used])
}

model BlacklistedToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([expiresAt])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String
  entity    String
  entityId  String
  details   Json?
  ipAddress String?
  timestamp DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@index([entityId])
  @@index([timestamp])
  @@index([userId])
}

// ============================================================================
// EXAM MODELS (Keep if using exam features)
// ============================================================================

model ExamSession {
  id               String                   @id @default(uuid())
  batchQrCode      String                   @unique
  courseCode       String
  courseName       String
  lecturerId       String
  lecturerName     String
  department       String
  faculty          String
  venue            String
  examDate         DateTime
  status           BatchStatus              @default(NOT_STARTED)
  createdById      String
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  invigilatorId    String?
  invigilatorName  String?
  transfers        BatchTransfer[]
  attendances      ExamAttendance[]
  createdBy        User                     @relation("CreatedBy", fields: [createdById], references: [id])
  invigilator      User?                    @relation("Invigilator", fields: [invigilatorId], references: [id])
  invigilators     ExamSessionInvigilator[]
  expectedStudents ExamSessionStudent[]
  incidents        Incident[]
}

model ExamSessionStudent {
  id            String      @id @default(uuid())
  examSessionId String
  createdAt     DateTime    @default(now())
  firstName     String?
  indexNumber   String
  lastName      String?
  level         Int?
  program       String?
  examSession   ExamSession @relation(fields: [examSessionId], references: [id], onDelete: Cascade)

  @@unique([examSessionId, indexNumber])
  @@index([examSessionId])
  @@index([indexNumber])
}

model ExamSessionInvigilator {
  id              String          @id @default(uuid())
  examSessionId   String
  userId          String
  role            InvigilatorRole @default(ASSISTANT)
  assignedAt      DateTime        @default(now())
  firstScanAt     DateTime?
  lastScanAt      DateTime?
  studentsScanned Int             @default(0)
  examSession     ExamSession     @relation(fields: [examSessionId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id])

  @@unique([examSessionId, userId])
  @@index([examSessionId])
  @@index([userId])
}

model ExamAttendance {
  id              String           @id @default(uuid())
  studentId       String
  examSessionId   String
  entryTime       DateTime
  exitTime        DateTime?
  submissionTime  DateTime?
  status          ExamAttendanceStatus @default(PRESENT)
  discrepancyNote String?
  examSession     ExamSession      @relation(fields: [examSessionId], references: [id])
  student         Student          @relation(fields: [studentId], references: [id])
  incidents       Incident[]

  @@unique([studentId, examSessionId])
}

model BatchTransfer {
  id              String         @id @default(uuid())
  examSessionId   String
  fromHandlerId   String
  toHandlerId     String
  requestedAt     DateTime       @default(now())
  confirmedAt     DateTime?
  status          TransferStatus @default(PENDING)
  examsExpected   Int            @map("scriptsExpected")
  examsReceived   Int?           @map("scriptsReceived")
  discrepancyNote String?
  location        String?
  examSession     ExamSession    @relation(fields: [examSessionId], references: [id])
  fromHandler     User           @relation("Handler", fields: [fromHandlerId], references: [id])
  toHandler       User           @relation("Receiver", fields: [toHandlerId], references: [id])
  incidents       Incident[]

  @@index([examSessionId])
}

// ============================================================================
// INCIDENT MODELS (Keep if using incident features)
// ============================================================================

model Incident {
  id              String                  @id @default(uuid())
  incidentNumber  String                  @unique
  type            IncidentType
  severity        IncidentSeverity
  status          IncidentStatus          @default(REPORTED)
  isConfidential  Boolean                 @default(false)
  autoCreated     Boolean                 @default(false)
  title           String
  description     String
  location        String?
  reporterId      String
  assigneeId      String?
  studentId       String?
  examSessionId   String?
  attendanceId    String?
  transferId      String?
  incidentDate    DateTime
  reportedAt      DateTime                @default(now())
  assignedAt      DateTime?
  resolvedAt      DateTime?
  closedAt        DateTime?
  metadata        Json?
  resolutionNotes String?
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  assignee        User?                   @relation("IncidentAssignee", fields: [assigneeId], references: [id])
  attendance      ExamAttendance?         @relation(fields: [attendanceId], references: [id])
  examSession     ExamSession?            @relation(fields: [examSessionId], references: [id])
  reporter        User                    @relation("IncidentReporter", fields: [reporterId], references: [id])
  student         Student?                @relation(fields: [studentId], references: [id])
  transfer        BatchTransfer?          @relation(fields: [transferId], references: [id])
  attachments     IncidentAttachment[]
  comments        IncidentComment[]
  statusHistory   IncidentStatusHistory[]

  @@index([reporterId])
  @@index([assigneeId])
  @@index([studentId])
  @@index([examSessionId])
  @@index([status])
  @@index([severity])
  @@index([type])
  @@index([incidentDate])
  @@index([isConfidential])
}

model IncidentAttachment {
  id         String   @id @default(uuid())
  incidentId String
  fileName   String
  filePath   String
  fileType   String
  fileSize   Int
  uploadedBy String
  uploadedAt DateTime @default(now())
  metadata   Json?
  incident   Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  uploader   User     @relation(fields: [uploadedBy], references: [id])

  @@index([incidentId])
}

model IncidentComment {
  id         String   @id @default(uuid())
  incidentId String
  userId     String
  comment    String
  isInternal Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  incident   Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id])

  @@index([incidentId])
  @@index([userId])
}

model IncidentStatusHistory {
  id         String          @id @default(uuid())
  incidentId String
  fromStatus IncidentStatus?
  toStatus   IncidentStatus
  changedBy  String
  reason     String?
  changedAt  DateTime        @default(now())
  user       User            @relation(fields: [changedBy], references: [id])
  incident   Incident        @relation(fields: [incidentId], references: [id], onDelete: Cascade)

  @@index([incidentId])
  @@index([changedAt])
}

// ============================================================================
// ADDITIONAL ENUMS
// ============================================================================

enum BatchStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  IN_TRANSIT
  WITH_LECTURER
  UNDER_GRADING
  GRADED
  RETURNED
  COMPLETED
}

enum InvigilatorRole {
  PRIMARY
  ASSISTANT
}

enum ExamAttendanceStatus {
  PRESENT
  SUBMITTED
  LEFT_WITHOUT_SUBMITTING
  ABSENT
}

enum TransferStatus {
  PENDING
  CONFIRMED
  DISCREPANCY_REPORTED
  RESOLVED
}

enum IncidentType {
  MALPRACTICE
  HEALTH_ISSUE
  EXAM_DAMAGE
  EQUIPMENT_FAILURE
  DISRUPTION
  SECURITY_BREACH
  PROCEDURAL_VIOLATION
  OTHER
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentStatus {
  REPORTED
  UNDER_INVESTIGATION
  RESOLVED
  CLOSED
  ESCALATED
}