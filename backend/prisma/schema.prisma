// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users & Roles
model User {
  id                String   @id @default(uuid())
  email             String   @unique
  password          String
  role              Role
  firstName         String
  lastName          String
  phone             String?
  department        String?  // User's department
  profilePicture    String?  // URL or path to profile picture
  isActive          Boolean  @default(true)
  isSuperAdmin      Boolean  @default(false)
  passwordChanged   Boolean  @default(false)
  lastLogin         DateTime?
  failedLoginAttempts Int    @default(0)
  lockedUntil       DateTime?
  registrationToken String?  @unique // Token for QR code registration
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  handledBatches  BatchTransfer[] @relation("Handler")
  receivedBatches BatchTransfer[] @relation("Receiver")
  createdExams    ExamSession[]   @relation("CreatedBy")
  invigilatedExams ExamSession[]  @relation("Invigilator")  // Exams where this user is the invigilator
  invigilatorHistory ExamSessionInvigilator[] // All sessions where user was an invigilator
  auditLogs       AuditLog[]
  refreshTokens   RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  createdRegistrationSessions RegistrationSession[]
  
  // Incident Management relations
  reportedIncidents      Incident[]              @relation("IncidentReporter")
  assignedIncidents      Incident[]              @relation("IncidentAssignee")
  incidentComments       IncidentComment[]
  incidentStatusChanges  IncidentStatusHistory[]
  incidentAttachments    IncidentAttachment[]
  
  // Class Attendance relations
  classAttendanceRecords ClassAttendanceRecord[]
  createdAttendanceLinks AttendanceLink[]
}

// Password Reset Tokens
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Registration Session for QR Code Registration
model RegistrationSession {
  id          String   @id @default(uuid())
  qrToken     String   @unique // Token encoded in QR code
  createdById String   // Admin who created the session
  department  String?  // Department to assign to users who register with this QR
  expiresAt   DateTime // When the QR code expires
  used        Boolean  @default(false)
  usedAt      DateTime?
  createdAt   DateTime @default(now())
  
  createdBy User @relation(fields: [createdById], references: [id])
  
  @@index([qrToken])
  @@index([expiresAt])
  @@index([used])
}

// Blacklisted Access Tokens (for immediate session revocation)
model BlacklistedToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime // When the token would naturally expire
  createdAt DateTime @default(now())
  
  @@index([token])
  @@index([expiresAt])
}

enum Role {
  ADMIN
  INVIGILATOR
  DEPARTMENT_HEAD
  FACULTY_OFFICER
  LECTURER
  CLASS_REP
}

// Students
model Student {
  id          String   @id @default(uuid())
  indexNumber String   @unique
  firstName   String
  lastName    String
  program     String
  level       Int
  qrCode      String   @unique
  profilePicture String // Path to profile picture file

  // NEW: Biometric Fields
  biometricTemplateHash String?  @unique  // Hashed biometric template
  biometricEnrolledAt   DateTime?          // When biometrics were enrolled
  biometricDeviceId     String?            // Device used for enrollment
  biometricProvider     String?            // 'TOUCHID', 'FACEID', 'FINGERPRINT'

  createdAt   DateTime @default(now())
  
  attendances       ExamAttendance[]
  classAttendances  ClassAttendance[]
  incidents         Incident[]
  enrollmentLinks   AttendanceLink[] @relation("enrollmentLinks")

  @@index([biometricTemplateHash])
}

// Attendance Link for Self-Service Biometric Enrollment
model AttendanceLink {
  id                String   @id @default(uuid())
  recordId          String?  // Links to ClassAttendanceRecord (optional for enrollment)
  linkToken         String   @unique  // Short-lived unique token
  createdBy         String   // User who created the link
  createdByUser     User     @relation(fields: [createdBy], references: [id])

  // NEW: Enrollment Support
  studentId         String?  // For biometric enrollment links
  student           Student? @relation("enrollmentLinks", fields: [studentId], references: [id])
  enrollmentToken   String?  @unique  // Separate token for enrollment
  linkType          String   @default("ATTENDANCE") // "ATTENDANCE" or "BIOMETRIC_ENROLLMENT"

  // Security Constraints
  geolocation       Json?    // {lat, lng, radius} - origin device location
  networkIdentifier String?  // IP/subnet for local network validation
  expiresAt         DateTime // Link validity (e.g., 30 mins)
  maxUses           Int?     // Optional: limit total uses
  usesCount         Int      @default(0)

  // Status
  isActive          Boolean  @default(true)
  deactivatedAt     DateTime?

  createdAt         DateTime @default(now())

  @@index([linkToken])
  @@index([recordId, isActive])
  @@index([enrollmentToken])
  @@index([studentId, linkType])
}

// Exam Sessions
model ExamSession {
  id           String      @id @default(uuid())
  batchQrCode  String      @unique
  courseCode   String
  courseName   String
  lecturerId   String
  lecturerName String
  department   String
  faculty      String
  venue        String
  examDate     DateTime
  status       BatchStatus @default(NOT_STARTED)
  invigilatorId String?    // ID of the user who first scanned a student
  invigilatorName String?  // Name of the invigilator
  createdById  String
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  createdBy        User                 @relation("CreatedBy", fields: [createdById], references: [id])
  invigilator      User?                @relation("Invigilator", fields: [invigilatorId], references: [id])
  attendances      ExamAttendance[]
  transfers        BatchTransfer[]
  expectedStudents ExamSessionStudent[]
  incidents        Incident[]
  invigilators     ExamSessionInvigilator[]
}
enum BatchStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  IN_TRANSIT
  WITH_LECTURER
  UNDER_GRADING
  GRADED
  RETURNED
  COMPLETED
}

// Expected Students for Exam Sessions (Raw Data - No User Account Required)
model ExamSessionStudent {
  id            String      @id @default(uuid())
  examSessionId String
  indexNumber   String      // Student's index number (raw data)
  firstName     String?     // Optional: student name from CSV
  lastName      String?     // Optional: student name from CSV
  program       String?     // Optional: program from CSV
  level         Int?        // Optional: level from CSV
  createdAt     DateTime    @default(now())
  
  examSession ExamSession @relation(fields: [examSessionId], references: [id], onDelete: Cascade)
  
  @@unique([examSessionId, indexNumber])
  @@index([examSessionId])
  @@index([indexNumber])
}

// Invigilator History for Exam Sessions (Tracks all users who scanned students)
model ExamSessionInvigilator {
  id              String            @id @default(uuid())
  examSessionId   String
  userId          String
  role            InvigilatorRole   @default(ASSISTANT)
  assignedAt      DateTime          @default(now()) // When they first scanned
  firstScanAt     DateTime?         // First scan timestamp
  lastScanAt      DateTime?         // Last scan timestamp
  studentsScanned Int               @default(0)     // Count of students scanned
  
  examSession     ExamSession       @relation(fields: [examSessionId], references: [id], onDelete: Cascade)
  user            User              @relation(fields: [userId], references: [id])
  
  @@unique([examSessionId, userId])
  @@index([examSessionId])
  @@index([userId])
}

enum InvigilatorRole {
  PRIMARY   // First scanner for the session
  ASSISTANT // Subsequent scanners
}

// Student Attendance & Submission
model ExamAttendance {
  id              String           @id @default(uuid())
  studentId       String
  examSessionId   String
  entryTime       DateTime
  exitTime        DateTime?
  submissionTime  DateTime?
  status          AttendanceStatus @default(PRESENT)
  discrepancyNote String?
  
  student     Student     @relation(fields: [studentId], references: [id])
  examSession ExamSession @relation(fields: [examSessionId], references: [id])
  incidents   Incident[]
  
  @@unique([studentId, examSessionId])
}

enum AttendanceStatus {
  PRESENT
  SUBMITTED
  LEFT_WITHOUT_SUBMITTING
  ABSENT
}

// Exam Transfer Chain
model BatchTransfer {
  id              String         @id @default(uuid())
  examSessionId   String
  fromHandlerId   String
  toHandlerId     String
  requestedAt     DateTime       @default(now())
  confirmedAt     DateTime?
  status          TransferStatus @default(PENDING)
  examsExpected Int @map("scriptsExpected")
  examsReceived Int? @map("scriptsReceived")
  discrepancyNote String?
  location        String?
  
  examSession ExamSession @relation(fields: [examSessionId], references: [id])
  fromHandler User        @relation("Handler", fields: [fromHandlerId], references: [id])
  toHandler   User        @relation("Receiver", fields: [toHandlerId], references: [id])
  incidents   Incident[]
  
  @@index([examSessionId])
}

enum TransferStatus {
  PENDING
  CONFIRMED
  DISCREPANCY_REPORTED
  RESOLVED
}

// Audit Trail
model AuditLog {
  id        String   @id @default(uuid())
  userId    String?  // Optional for public actions
  action    String
  entity    String
  entityId  String
  details   Json?
  ipAddress String?
  timestamp DateTime @default(now())
  
  user User? @relation(fields: [userId], references: [id])
  
  @@index([entityId])
  @@index([timestamp])
  @@index([userId])
}

// Class Attendance System Models

// Class Attendance Session (Device-based sessions)
model AttendanceSession {
  id              String   @id @default(uuid())
  deviceId        String   @unique // Device UUID or fingerprint
  deviceName      String?  // User-provided device label
  sessionToken    String   @unique // Unique session token
  isActive        Boolean  @default(true)
  lastActivity    DateTime @updatedAt
  createdAt       DateTime @default(now())

  attendanceRecords ClassAttendanceRecord[]

  @@index([deviceId])
  @@index([isActive])
}

// Class Attendance Recording
model ClassAttendanceRecord {
  id               String            @id @default(uuid())
  sessionId        String
  userId           String?           // User who created this record (optional for migration)
  lecturerName     String?           // Optional label
  courseName       String?           // Optional label
  courseCode       String?           // Optional label
  startTime        DateTime          @default(now())
  endTime          DateTime?
  status           RecordingStatus   @default(IN_PROGRESS)
  totalStudents    Int               @default(0)
  notes            String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  session          AttendanceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user             User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  students         ClassAttendance[]

  @@index([sessionId])
  @@index([userId])
  @@index([startTime])
}

// Individual Student Attendance
model ClassAttendance {
  id               String                  @id @default(uuid())
  recordId         String
  studentId        String                  // From Student model
  scanTime         DateTime                @default(now())
  status           ClassAttendanceStatus   @default(PRESENT)
  lecturerConfirmed Boolean               @default(true) // Auto-confirmed for QR scans, manual for manual entries
  confirmedAt      DateTime?

  // NEW: Method tracking
  verificationMethod   AttendanceMethod?  @default(QR_CODE)
  deviceId             String?           // Device used for verification
  linkTokenUsed        String?           // If via self-service link
  biometricConfidence  Float?            // Quality score (0-1)

  record           ClassAttendanceRecord   @relation(fields: [recordId], references: [id], onDelete: Cascade)
  student          Student                 @relation(fields: [studentId], references: [id])

  @@unique([recordId, studentId])
  @@index([recordId])
  @@index([scanTime])
}

// Enums for Class Attendance System
enum RecordingStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ClassAttendanceStatus {
  PRESENT
  LATE
  EXCUSED
}

enum AttendanceMethod {
  QR_CODE
  MANUAL_INDEX
  BIOMETRIC_FINGERPRINT
  BIOMETRIC_FACE
}

// Refresh Tokens
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

// ============================================
// INCIDENT MANAGEMENT SYSTEM
// ============================================

// Incident Types
enum IncidentType {
  MALPRACTICE           // Cheating, unauthorized materials
  HEALTH_ISSUE          // Medical emergency, student unwell
  EXAM_DAMAGE         // Water damage, torn papers
  EQUIPMENT_FAILURE     // Scanner issues, printer problems
  DISRUPTION            // Fire alarm, power outage
  SECURITY_BREACH       // Unauthorized access
  PROCEDURAL_VIOLATION  // Protocol not followed
  OTHER                 // Miscellaneous
}

enum IncidentSeverity {
  LOW       // Minor issue, no immediate action needed
  MEDIUM    // Requires attention within 24h
  HIGH      // Urgent, requires immediate attention
  CRITICAL  // Emergency, escalate immediately
}

enum IncidentStatus {
  REPORTED              // Initial state, awaiting review
  UNDER_INVESTIGATION   // Assigned and being investigated
  RESOLVED              // Investigation complete, action taken
  CLOSED                // No further action needed
  ESCALATED             // Sent to higher authority
}

// Main Incident Model
model Incident {
  id                String            @id @default(uuid())
  incidentNumber    String            @unique // Auto-generated: INC-YYYYMMDD-XXXX
  
  // Classification
  type              IncidentType
  severity          IncidentSeverity
  status            IncidentStatus    @default(REPORTED)
  isConfidential    Boolean           @default(false)
  autoCreated       Boolean           @default(false)
  
  // Description
  title             String            // Brief summary
  description       String            @db.Text // Detailed description
  location          String?           // Venue/room where incident occurred
  
  // Relationships
  reporterId        String            // User who reported
  assigneeId        String?           // User assigned to investigate
  studentId         String?           // Involved student (optional)
  examSessionId     String?           // Related exam session (optional)
  attendanceId      String?           // Related attendance record (optional)
  transferId        String?           // Related batch transfer (optional)
  
  // Metadata
  incidentDate      DateTime          // When incident occurred
  reportedAt        DateTime          @default(now())
  assignedAt        DateTime?
  resolvedAt        DateTime?
  closedAt          DateTime?
  
  // Additional data
  metadata          Json?             // Flexible field for extra context
  resolutionNotes   String?           @db.Text
  
  // Relations
  reporter          User              @relation("IncidentReporter", fields: [reporterId], references: [id], onDelete: Restrict)
  assignee          User?             @relation("IncidentAssignee", fields: [assigneeId], references: [id], onDelete: SetNull)
  student           Student?          @relation(fields: [studentId], references: [id], onDelete: SetNull)
  examSession       ExamSession?      @relation(fields: [examSessionId], references: [id], onDelete: SetNull)
  attendance        ExamAttendance?   @relation(fields: [attendanceId], references: [id], onDelete: SetNull)
  transfer          BatchTransfer?    @relation(fields: [transferId], references: [id], onDelete: SetNull)
  
  attachments       IncidentAttachment[]
  comments          IncidentComment[]
  statusHistory     IncidentStatusHistory[]
  
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([reporterId])
  @@index([assigneeId])
  @@index([studentId])
  @@index([examSessionId])
  @@index([status])
  @@index([severity])
  @@index([type])
  @@index([incidentDate])
  @@index([isConfidential])
}

// Incident Attachments (Photos, Videos, Documents)
model IncidentAttachment {
  id           String   @id @default(uuid())
  incidentId   String
  
  fileName     String   // Original filename
  filePath     String   // Relative path or cloud URL
  fileType     String   // MIME type: image/jpeg, video/mp4, application/pdf
  fileSize     Int      // Size in bytes
  
  uploadedBy   String   // User who uploaded
  uploadedAt   DateTime @default(now())
  
  // Cloud storage metadata (publicId, provider, etc.)
  metadata     Json?
  
  incident     Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  uploader     User     @relation(fields: [uploadedBy], references: [id], onDelete: Restrict)
  
  @@index([incidentId])
}

// Comments/Notes Thread
model IncidentComment {
  id          String   @id @default(uuid())
  incidentId  String
  userId      String
  
  comment     String   @db.Text
  isInternal  Boolean  @default(false) // Internal notes vs public comments
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  incident    Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  
  @@index([incidentId])
  @@index([userId])
}

// Status Change History (Audit Trail)
model IncidentStatusHistory {
  id          String         @id @default(uuid())
  incidentId  String
  
  fromStatus  IncidentStatus?
  toStatus    IncidentStatus
  changedBy   String
  reason      String?        @db.Text
  
  changedAt   DateTime       @default(now())
  
  incident    Incident       @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user        User           @relation(fields: [changedBy], references: [id], onDelete: Restrict)
  
  @@index([incidentId])
  @@index([changedAt])
}
